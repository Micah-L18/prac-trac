const express = require('express');
const cors = require('cors');
const morgan = require('morgan');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const path = require('path');
const sqlite3 = require('sqlite3').verbose();
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const Joi = require('joi');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3001;
const HOST = process.env.HOST || 'localhost';

// Initialize database
const dbPath = path.join(__dirname, process.env.DB_PATH || '../database/practrac.db');
const db = new sqlite3.Database(dbPath);
db.run('PRAGMA foreign_keys = ON');

// Security middleware
app.use(helmet());
app.use(cors());
app.use(morgan('combined'));
app.use(express.json({ limit: '10mb' }));

// Rate limiting
const generalLimiter = rateLimit({
  windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 60000,
  max: parseInt(process.env.RATE_LIMIT_MAX_REQUESTS) || 100,
  message: { success: false, error: 'Too many requests, please try again later' }
});

const authLimiter = rateLimit({
  windowMs: parseInt(process.env.RATE_LIMIT_WINDOW_MS) || 60000,
  max: parseInt(process.env.AUTH_RATE_LIMIT_MAX) || 5,
  message: { success: false, error: 'Too many authentication attempts, please try again later' }
});

app.use('/api/', generalLimiter);
app.use('/api/auth/login', authLimiter);
app.use('/api/auth/register', authLimiter);

// Initialize database tables (only essential ones - no practice tables)
db.serialize(() => {
  // Coaches table (users)
  db.run(`
    CREATE TABLE IF NOT EXISTS coaches (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      email TEXT UNIQUE NOT NULL,
      password_hash TEXT NOT NULL,
      first_name TEXT NOT NULL,
      last_name TEXT NOT NULL,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      verified INTEGER DEFAULT 0,
      verification_token TEXT,
      phone TEXT,
      bio TEXT,
      coaching_experience TEXT,
      certifications TEXT
    )
  `);

  // Coach sessions for token management
  db.run(`
    CREATE TABLE IF NOT EXISTS coach_sessions (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      coach_id INTEGER NOT NULL,
      token_hash TEXT NOT NULL,
      expires_at DATETIME NOT NULL,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (coach_id) REFERENCES coaches (id) ON DELETE CASCADE
    )
  `);

  // Teams table
  db.run(`
    CREATE TABLE IF NOT EXISTS teams (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      coach_id INTEGER NOT NULL,
      name TEXT NOT NULL,
      season TEXT,
      division TEXT,
      description TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (coach_id) REFERENCES coaches (id) ON DELETE CASCADE
    )
  `);

  // Players table
  db.run(`
    CREATE TABLE IF NOT EXISTS players (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      team_id INTEGER NOT NULL,
      firstName TEXT NOT NULL,
      lastName TEXT NOT NULL,
      position TEXT,
      jerseyNumber INTEGER,
      email TEXT,
      phone TEXT,
      emergencyContact TEXT,
      emergencyPhone TEXT,
      notes TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      height REAL,
      weight REAL,
      yearInSchool TEXT,
      gpa REAL,
      FOREIGN KEY (team_id) REFERENCES teams (id) ON DELETE CASCADE
    )
  `);

  // Drills table
  db.run(`
    CREATE TABLE IF NOT EXISTS drills (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      coach_id INTEGER NOT NULL,
      name TEXT NOT NULL,
      description TEXT,
      category TEXT,
      duration INTEGER,
      difficulty TEXT,
      equipment TEXT,
      instructions TEXT,
      notes TEXT,
      courtDiagram TEXT,
      tags TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (coach_id) REFERENCES coaches (id) ON DELETE CASCADE
    )
  `);

  // Active team selection table
  db.run(`
    CREATE TABLE IF NOT EXISTS coach_active_team (
      coach_id INTEGER PRIMARY KEY,
      team_id INTEGER,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (coach_id) REFERENCES coaches (id) ON DELETE CASCADE,
      FOREIGN KEY (team_id) REFERENCES teams (id) ON DELETE SET NULL
    )
  `);

  // =============================================================================
  // PRACTICE MANAGEMENT TABLES
  // =============================================================================

  // Practices table - stores practice plans
  db.run(`
    CREATE TABLE IF NOT EXISTS practices (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      coach_id INTEGER NOT NULL,
      name TEXT NOT NULL,
      objective TEXT,
      estimated_duration INTEGER DEFAULT 90,
      date TEXT NOT NULL,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (coach_id) REFERENCES coaches (id) ON DELETE CASCADE
    )
  `);

  // Practice phases table - stores individual phases within a practice
  db.run(`
    CREATE TABLE IF NOT EXISTS practice_phases (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      practice_id INTEGER NOT NULL,
      name TEXT NOT NULL,
      duration INTEGER NOT NULL,
      objective TEXT,
      phase_order INTEGER NOT NULL,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (practice_id) REFERENCES practices (id) ON DELETE CASCADE
    )
  `);

  // Practice phase drills table - links drills to practice phases
  db.run(`
    CREATE TABLE IF NOT EXISTS practice_phase_drills (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      phase_id INTEGER NOT NULL,
      drill_id INTEGER NOT NULL,
      drill_order INTEGER DEFAULT 0,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (phase_id) REFERENCES practice_phases (id) ON DELETE CASCADE,
      FOREIGN KEY (drill_id) REFERENCES drills (id) ON DELETE CASCADE
    )
  `);

  // Practice sessions table - stores active/completed practice sessions
  db.run(`
    CREATE TABLE IF NOT EXISTS practice_sessions (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      practice_id INTEGER NOT NULL,
      status TEXT DEFAULT 'in_progress',
      started_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      completed_at DATETIME,
      actual_duration INTEGER,
      notes TEXT,
      timer_state TEXT,
      current_phase_id INTEGER,
      phase_elapsed_time INTEGER DEFAULT 0,
      total_elapsed_time INTEGER DEFAULT 0,
      last_activity DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (practice_id) REFERENCES practices (id) ON DELETE CASCADE,
      FOREIGN KEY (current_phase_id) REFERENCES practice_phases (id) ON DELETE SET NULL
    )
  `);

  // Practice attendance table - stores player attendance for each session
  db.run(`
    CREATE TABLE IF NOT EXISTS practice_attendance (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      session_id INTEGER NOT NULL,
      player_id INTEGER NOT NULL,
      attended INTEGER DEFAULT 1,
      late_minutes INTEGER DEFAULT 0,
      notes TEXT,
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (session_id) REFERENCES practice_sessions (id) ON DELETE CASCADE,
      FOREIGN KEY (player_id) REFERENCES players (id) ON DELETE CASCADE
    )
  `);

  // Player notes table - stores coach notes about players during practices
  db.run(`
    CREATE TABLE IF NOT EXISTS player_notes (
      id INTEGER PRIMARY KEY AUTOINCREMENT,
      session_id INTEGER NOT NULL,
      player_id INTEGER NOT NULL,
      notes TEXT NOT NULL,
      note_type TEXT DEFAULT 'practice',
      created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (session_id) REFERENCES practice_sessions (id) ON DELETE CASCADE,
      FOREIGN KEY (player_id) REFERENCES players (id) ON DELETE CASCADE
    )
  `);
});

console.log('âœ… Database tables initialized');

// JWT Configuration
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key-change-this-in-production';
const JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '7d';

// Authentication middleware
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (token == null) {
    return res.status(401).json({ success: false, error: 'Access token required' });
  }

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ success: false, error: 'Invalid or expired token' });
    }
    req.user = user;
    next();
  });
};

// Middleware to ensure user has an active team selected
const requireActiveTeam = (req, res, next) => {
  const query = `SELECT team_id FROM coach_active_team WHERE coach_id = ?`;
  
  db.get(query, [req.user.id], (err, row) => {
    if (err) {
      console.error('Database error:', err);
      return res.status(500).json({ success: false, error: 'Internal server error' });
    }
    
    if (!row || !row.team_id) {
      return res.status(400).json({ 
        success: false, 
        error: 'No active team selected. Please select a team first.',
        requiresTeamSelection: true
      });
    }
    
    req.activeTeamId = row.team_id;
    next();
  });
};

// Helper function to get coach's teams
const getCoachTeams = (coachId, callback) => {
  const query = `SELECT * FROM teams WHERE coach_id = ? ORDER BY created_at DESC`;
  
  db.all(query, [coachId], (err, rows) => {
    if (err) {
      return callback(err, null);
    }
    callback(null, rows);
  });
};

// Helper function to set active team
const setActiveTeam = (coachId, teamId, callback) => {
  // First verify the coach owns this team
  const verifyQuery = `SELECT id FROM teams WHERE id = ? AND coach_id = ?`;
  
  db.get(verifyQuery, [teamId, coachId], (err, team) => {
    if (err) {
      return callback(err);
    }
    
    if (!team) {
      return callback(new Error('Team not found or access denied'));
    }
    
    // Update or insert active team
    const upsertQuery = `
      INSERT INTO coach_active_team (coach_id, team_id, updated_at)
      VALUES (?, ?, CURRENT_TIMESTAMP)
      ON CONFLICT(coach_id) DO UPDATE SET 
        team_id = excluded.team_id,
        updated_at = excluded.updated_at
    `;
    
    db.run(upsertQuery, [coachId, teamId], (err) => {
      callback(err);
    });
  });
};

// ===================
// AUTH ROUTES
// ===================

// Register endpoint
app.post('/api/auth/register', async (req, res) => {
  try {
    const schema = Joi.object({
      email: Joi.string().email().required(),
      password: Joi.string().min(8).required(),
      firstName: Joi.string().required(),
      lastName: Joi.string().required(),
      phone: Joi.string().optional(),
      bio: Joi.string().optional(),
      coachingExperience: Joi.string().optional(),
      certifications: Joi.string().optional()
    });

    const { error, value } = schema.validate(req.body);
    if (error) {
      console.log('Validation error:', error.details[0].message);
      console.log('Request body:', req.body);
      return res.status(400).json({ success: false, error: error.details[0].message });
    }

    const { email, password, firstName, lastName, phone, bio, coachingExperience, certifications } = value;

    // Check if user already exists
    db.get('SELECT id FROM coaches WHERE email = ?', [email], async (err, row) => {
      if (err) {
        console.error('Database error:', err);
        return res.status(500).json({ success: false, error: 'Internal server error' });
      }

      if (row) {
        return res.status(400).json({ success: false, error: 'Email already registered' });
      }

      // Hash password
      const passwordHash = await bcrypt.hash(password, 12);

      // Insert new coach
      const insertQuery = `
        INSERT INTO coaches (email, password_hash, first_name, last_name, phone, bio, coaching_experience, certifications)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
      `;

      db.run(insertQuery, [email, passwordHash, firstName, lastName, phone, bio, coachingExperience, certifications], function(err) {
        if (err) {
          console.error('Database error:', err);
          return res.status(500).json({ success: false, error: 'Internal server error' });
        }

        const userId = this.lastID;

        // Generate JWT token
        const token = jwt.sign({ id: userId, email }, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });

        res.status(201).json({
          success: true,
          message: 'Account created successfully',
          data: {
            user: {
              id: userId,
              email,
              first_name: firstName,
              last_name: lastName,
              phone,
              bio,
              coaching_experience: coachingExperience,
              certifications
            },
            token
          }
        });
      });
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ success: false, error: 'Internal server error' });
  }
});

// Login endpoint
app.post('/api/auth/login', async (req, res) => {
  try {
    const schema = Joi.object({
      email: Joi.string().email().required(),
      password: Joi.string().required()
    });

    const { error, value } = schema.validate(req.body);
    if (error) {
      return res.status(400).json({ success: false, error: error.details[0].message });
    }

    const { email, password } = value;

    // Find user
    db.get('SELECT * FROM coaches WHERE email = ?', [email], async (err, user) => {
      if (err) {
        console.error('Database error:', err);
        return res.status(500).json({ success: false, error: 'Internal server error' });
      }

      if (!user) {
        return res.status(401).json({ success: false, error: 'Invalid credentials' });
      }

      // Verify password
      const passwordValid = await bcrypt.compare(password, user.password_hash);
      if (!passwordValid) {
        return res.status(401).json({ success: false, error: 'Invalid credentials' });
      }

      // Generate JWT token
      const token = jwt.sign({ id: user.id, email: user.email }, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });

      // Remove password from response
      delete user.password_hash;

      res.json({
        success: true,
        message: 'Login successful',
        data: { user, token }
      });
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ success: false, error: 'Internal server error' });
  }
});

// Get current user
app.get('/api/auth/me', authenticateToken, (req, res) => {
  db.get('SELECT id, email, first_name, last_name, phone, bio, coaching_experience, certifications, created_at FROM coaches WHERE id = ?', [req.user.id], (err, user) => {
    if (err) {
      console.error('Database error:', err);
      return res.status(500).json({ success: false, error: 'Internal server error' });
    }

    if (!user) {
      return res.status(404).json({ success: false, error: 'User not found' });
    }

    res.json({ success: true, data: user });
  });
});

// ===================
// TEAM ROUTES
// ===================

// Get all teams for the authenticated coach
app.get('/api/teams', authenticateToken, (req, res) => {
  getCoachTeams(req.user.id, (err, teams) => {
    if (err) {
      console.error('Database error:', err);
      return res.status(500).json({ success: false, error: 'Internal server error' });
    }

    res.json({ success: true, data: teams });
  });
});

// Get active team
app.get('/api/teams/active', authenticateToken, (req, res) => {
  const query = `
    SELECT t.* 
    FROM teams t
    JOIN coach_active_team cat ON t.id = cat.team_id
    WHERE cat.coach_id = ?
  `;
  
  db.get(query, [req.user.id], (err, team) => {
    if (err) {
      console.error('Database error:', err);
      return res.status(500).json({ success: false, error: 'Internal server error' });
    }

    if (!team) {
      return res.status(404).json({ success: false, error: 'No active team selected' });
    }

    res.json({ success: true, data: team });
  });
});

// Set active team
app.post('/api/teams/:id/activate', authenticateToken, (req, res) => {
  const teamId = parseInt(req.params.id);

  setActiveTeam(req.user.id, teamId, (err) => {
    if (err) {
      console.error('Database error:', err);
      return res.status(500).json({ success: false, error: err.message || 'Internal server error' });
    }

    res.json({ success: true, message: 'Active team updated' });
  });
});

// Create a new team
app.post('/api/teams', authenticateToken, (req, res) => {
  const schema = Joi.object({
    name: Joi.string().required(),
    season: Joi.string().optional(),
    division: Joi.string().optional(),
    description: Joi.string().optional()
  });

  const { error, value } = schema.validate(req.body);
  if (error) {
    return res.status(400).json({ success: false, error: error.details[0].message });
  }

  const { name, season, division, description } = value;

  const query = `
    INSERT INTO teams (coach_id, name, season, division, description)
    VALUES (?, ?, ?, ?, ?)
  `;

  db.run(query, [req.user.id, name, season, division, description], function(err) {
    if (err) {
      console.error('Database error:', err);
      return res.status(500).json({ success: false, error: 'Internal server error' });
    }

    const teamId = this.lastID;

    // Get the created team
    db.get('SELECT * FROM teams WHERE id = ?', [teamId], (err, team) => {
      if (err) {
        console.error('Database error:', err);
        return res.status(500).json({ success: false, error: 'Internal server error' });
      }

      res.status(201).json({ success: true, data: team });
    });
  });
});

// ===================
// PLAYER ROUTES
// ===================

// Get all players for authenticated coach (across all teams)
app.get('/api/players', authenticateToken, (req, res) => {
  const query = `
    SELECT p.*, t.name as team_name 
    FROM players p
    JOIN teams t ON p.team_id = t.id
    WHERE t.coach_id = ?
    ORDER BY p.lastName, p.firstName
  `;

  db.all(query, [req.user.id], (err, players) => {
    if (err) {
      console.error('Database error:', err);
      return res.status(500).json({ success: false, error: 'Internal server error' });
    }

    res.json({ success: true, data: players });
  });
});

// Get players for a specific team
app.get('/api/teams/:teamId/players', authenticateToken, (req, res) => {
  const teamId = parseInt(req.params.teamId);

  // First verify the coach owns this team
  const verifyQuery = `SELECT id FROM teams WHERE id = ? AND coach_id = ?`;
  
  db.get(verifyQuery, [teamId, req.user.id], (err, team) => {
    if (err) {
      console.error('Database error:', err);
      return res.status(500).json({ success: false, error: 'Internal server error' });
    }
    
    if (!team) {
      return res.status(403).json({ success: false, error: 'Team not found or access denied' });
    }

    // Get players for this team
    const query = `SELECT * FROM players WHERE team_id = ? ORDER BY lastName, firstName`;
    
    db.all(query, [teamId], (err, players) => {
      if (err) {
        console.error('Database error:', err);
        return res.status(500).json({ success: false, error: 'Internal server error' });
      }

      res.json({ success: true, data: players });
    });
  });
});

// Add a new player to a team
app.post('/api/teams/:teamId/players', authenticateToken, (req, res) => {
  const teamId = parseInt(req.params.teamId);

  // First verify the coach owns this team
  const verifyQuery = `SELECT id FROM teams WHERE id = ? AND coach_id = ?`;
  
  db.get(verifyQuery, [teamId, req.user.id], (err, team) => {
    if (err) {
      console.error('Database error:', err);
      return res.status(500).json({ success: false, error: 'Internal server error' });
    }
    
    if (!team) {
      return res.status(403).json({ success: false, error: 'Team not found or access denied' });
    }

    const schema = Joi.object({
      firstName: Joi.string().required(),
      lastName: Joi.string().required(),
      position: Joi.string().optional(),
      jerseyNumber: Joi.number().integer().optional(),
      email: Joi.string().email().optional(),
      phone: Joi.string().optional(),
      emergencyContact: Joi.string().optional(),
      emergencyPhone: Joi.string().optional(),
      notes: Joi.string().optional(),
      height: Joi.number().optional(),
      weight: Joi.number().optional(),
      yearInSchool: Joi.string().optional(),
      gpa: Joi.number().optional()
    });

    const { error, value } = schema.validate(req.body);
    if (error) {
      return res.status(400).json({ success: false, error: error.details[0].message });
    }

    const insertQuery = `
      INSERT INTO players (
        team_id, firstName, lastName, position, jerseyNumber, email, phone,
        emergencyContact, emergencyPhone, notes, height, weight, yearInSchool, gpa
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;

    const values = [
      teamId, value.firstName, value.lastName, value.position, value.jerseyNumber,
      value.email, value.phone, value.emergencyContact, value.emergencyPhone,
      value.notes, value.height, value.weight, value.yearInSchool, value.gpa
    ];

    db.run(insertQuery, values, function(err) {
      if (err) {
        console.error('Database error:', err);
        return res.status(500).json({ success: false, error: 'Internal server error' });
      }

      const playerId = this.lastID;

      // Get the created player
      db.get('SELECT * FROM players WHERE id = ?', [playerId], (err, player) => {
        if (err) {
          console.error('Database error:', err);
          return res.status(500).json({ success: false, error: 'Internal server error' });
        }

        res.status(201).json({ success: true, data: player });
      });
    });
  });
});

// ===================
// DRILL ROUTES
// ===================

// Get all drills for the authenticated coach
app.get('/api/drills', authenticateToken, (req, res) => {
  const query = `SELECT * FROM drills WHERE coach_id = ? ORDER BY category, name`;

  db.all(query, [req.user.id], (err, drills) => {
    if (err) {
      console.error('Database error:', err);
      return res.status(500).json({ success: false, error: 'Internal server error' });
    }

    res.json({ success: true, data: drills });
  });
});

// Create a new drill
app.post('/api/drills', authenticateToken, (req, res) => {
  const schema = Joi.object({
    name: Joi.string().required(),
    description: Joi.string().optional(),
    category: Joi.string().optional(),
    duration: Joi.number().integer().optional(),
    difficulty: Joi.string().optional(),
    equipment: Joi.string().optional(),
    instructions: Joi.string().optional(),
    notes: Joi.string().optional(),
    courtDiagram: Joi.string().optional(),
    tags: Joi.string().optional()
  });

  const { error, value } = schema.validate(req.body);
  if (error) {
    return res.status(400).json({ success: false, error: error.details[0].message });
  }

  const insertQuery = `
    INSERT INTO drills (
      coach_id, name, description, category, duration, difficulty,
      equipment, instructions, notes, courtDiagram, tags
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `;

  const values = [
    req.user.id, value.name, value.description, value.category, value.duration,
    value.difficulty, value.equipment, value.instructions, value.notes,
    value.courtDiagram, value.tags
  ];

  db.run(insertQuery, values, function(err) {
    if (err) {
      console.error('Database error:', err);
      return res.status(500).json({ success: false, error: 'Internal server error' });
    }

    const drillId = this.lastID;

    // Get the created drill
    db.get('SELECT * FROM drills WHERE id = ?', [drillId], (err, drill) => {
      if (err) {
        console.error('Database error:', err);
        return res.status(500).json({ success: false, error: 'Internal server error' });
      }

      res.status(201).json({ success: true, data: drill });
    });
  });
});

// ===================
// ERROR HANDLING
// ===================

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({ success: false, error: 'Endpoint not found' });
});

// Global error handler
app.use((err, req, res, next) => {
  console.error('Unhandled error:', err);
  res.status(500).json({ success: false, error: 'Internal server error' });
});

// Start server
// =============================================================================
// PRACTICE MANAGEMENT ENDPOINTS
// =============================================================================

// Helper functions for practice data retrieval
const getPracticeByIdAsync = (practiceId, callback) => {
  db.get('SELECT * FROM practices WHERE id = ?', [practiceId], (err, practice) => {
    if (err) {
      console.error('Error fetching practice:', err);
      return callback(null);
    }
    
    if (!practice) {
      return callback(null);
    }
    
    // Get phases for this practice
    const phasesQuery = `
      SELECT pp.*, GROUP_CONCAT(d.id) as drill_ids, GROUP_CONCAT(d.name) as drill_names,
             GROUP_CONCAT(d.category) as drill_categories, GROUP_CONCAT(d.difficulty) as drill_difficulties,
             GROUP_CONCAT(d.description) as drill_descriptions, GROUP_CONCAT(d.duration) as drill_durations
      FROM practice_phases pp
      LEFT JOIN practice_phase_drills ppd ON pp.id = ppd.phase_id
      LEFT JOIN drills d ON ppd.drill_id = d.id
      WHERE pp.practice_id = ?
      GROUP BY pp.id
      ORDER BY pp.phase_order
    `;
    
    db.all(phasesQuery, [practiceId], (err, phases) => {
      if (err) {
        console.error('Error fetching practice phases:', err);
        return callback(practice);
      }
      
      // Format phases with drills
      practice.phases = phases.map(phase => {
        const drills = [];
        if (phase.drill_ids) {
          const ids = phase.drill_ids.split(',');
          const names = phase.drill_names.split(',');
          const categories = phase.drill_categories.split(',');
          const difficulties = phase.drill_difficulties.split(',');
          const descriptions = phase.drill_descriptions.split(',');
          const durations = phase.drill_durations.split(',');
          
          for (let i = 0; i < ids.length; i++) {
            drills.push({
              id: parseInt(ids[i]),
              name: names[i],
              category: categories[i],
              difficulty: difficulties[i],
              description: descriptions[i] === 'null' ? null : descriptions[i],
              duration: durations[i] ? parseInt(durations[i]) : null
            });
          }
        }
        
        return {
          id: phase.id,
          name: phase.name,
          duration: phase.duration,
          objective: phase.objective,
          phase_order: phase.phase_order,
          drills: drills
        };
      });
      
      callback(practice);
    });
  });
};

const getSessionByIdAsync = (sessionId, callback) => {
  const query = `
    SELECT ps.*, p.name as practice_name, p.objective, p.estimated_duration
    FROM practice_sessions ps
    JOIN practices p ON ps.practice_id = p.id
    WHERE ps.id = ?
  `;
  
  db.get(query, [sessionId], (err, session) => {
    if (err) {
      console.error('Error fetching session:', err);
      return callback(null);
    }
    
    if (!session) {
      return callback(null);
    }
    
    // Get attendance data
    db.all(`
      SELECT pa.*, pl.firstName, pl.lastName, pl.position, pl.jerseyNumber
      FROM practice_attendance pa
      JOIN players pl ON pa.player_id = pl.id
      WHERE pa.session_id = ?
    `, [sessionId], (err, attendance) => {
      if (err) {
        console.error('Error fetching attendance:', err);
        session.attendance = [];
      } else {
        session.attendance = attendance;
      }
      
      // Parse timer state if it exists
      if (session.timer_state) {
        try {
          session.timer_state = JSON.parse(session.timer_state);
        } catch (e) {
          session.timer_state = null;
        }
      }
      
      callback(session);
    });
  });
};

// Get all practices
app.get('/api/practices', authenticateToken, (req, res) => {
  const coachId = req.user.id;
  
  db.all(`
    SELECT p.*, COUNT(ps.id) as session_count
    FROM practices p
    LEFT JOIN practice_sessions ps ON p.id = ps.practice_id
    WHERE p.coach_id = ?
    GROUP BY p.id
    ORDER BY p.date DESC, p.created_at DESC
  `, [coachId], (err, practices) => {
    if (err) {
      console.error('Error fetching practices:', err);
      return res.status(500).json({ success: false, error: 'Internal server error' });
    }
    
    // For each practice, get phases count
    let completed = 0;
    const total = practices.length;
    
    if (total === 0) {
      return res.json({ success: true, data: [] });
    }
    
    practices.forEach((practice, index) => {
      db.get('SELECT COUNT(*) as phase_count FROM practice_phases WHERE practice_id = ?', [practice.id], (err, result) => {
        if (!err && result) {
          practices[index].phase_count = result.phase_count;
        }
        
        completed++;
        if (completed === total) {
          res.json({ success: true, data: practices });
        }
      });
    });
  });
});

// Get single practice with phases and drills
app.get('/api/practices/:id', authenticateToken, (req, res) => {
  const practiceId = parseInt(req.params.id);
  const coachId = req.user.id;
  
  // Verify coach owns this practice
  db.get('SELECT * FROM practices WHERE id = ? AND coach_id = ?', [practiceId, coachId], (err, practice) => {
    if (err) {
      console.error('Error fetching practice:', err);
      return res.status(500).json({ success: false, error: 'Internal server error' });
    }
    
    if (!practice) {
      return res.status(404).json({ success: false, error: 'Practice not found' });
    }
    
    getPracticeByIdAsync(practiceId, (completePractice) => {
      if (completePractice) {
        res.json({ success: true, data: completePractice });
      } else {
        res.status(500).json({ success: false, error: 'Failed to load practice details' });
      }
    });
  });
});

// Create new practice
app.post('/api/practices', authenticateToken, (req, res) => {
  const { name, objective, estimatedDuration, phases, date } = req.body;
  const coachId = req.user.id;
  
  // Validation
  if (!name || !date) {
    return res.status(400).json({ success: false, error: 'Name and date are required' });
  }
  
  const practiceDate = date || new Date().toISOString().split('T')[0];
  const duration = estimatedDuration || 90;
  
  // Insert practice
  db.run(`
    INSERT INTO practices (coach_id, name, objective, estimated_duration, date) 
    VALUES (?, ?, ?, ?, ?)
  `, [coachId, name, objective, duration, practiceDate], function(err) {
    if (err) {
      console.error('Error creating practice:', err);
      return res.status(500).json({ success: false, error: 'Failed to create practice' });
    }
    
    const practiceId = this.lastID;
    
    // Insert phases if provided
    if (phases && phases.length > 0) {
      let phasesCompleted = 0;
      const totalPhases = phases.length;
      
      phases.forEach((phase, index) => {
        db.run(`
          INSERT INTO practice_phases (practice_id, name, duration, objective, phase_order) 
          VALUES (?, ?, ?, ?, ?)
        `, [practiceId, phase.name, phase.duration, phase.objective, index + 1], function(err) {
          if (err) {
            console.error('Error creating phase:', err);
            return res.status(500).json({ success: false, error: 'Failed to create practice phase' });
          }
          
          const phaseId = this.lastID;
          
          // Insert drill assignments for this phase
          if (phase.drills && phase.drills.length > 0) {
            let drillsCompleted = 0;
            const totalDrills = phase.drills.length;
            
            phase.drills.forEach(drill => {
              const drillId = drill.id || drill;
              db.run(`
                INSERT INTO practice_phase_drills (phase_id, drill_id) 
                VALUES (?, ?)
              `, [phaseId, drillId], (err) => {
                if (err) {
                  console.error('Error assigning drill to phase:', err);
                  return res.status(500).json({ success: false, error: 'Failed to assign drills to phase' });
                }
                
                drillsCompleted++;
                if (drillsCompleted === totalDrills) {
                  phasesCompleted++;
                  if (phasesCompleted === totalPhases) {
                    getPracticeByIdAsync(practiceId, (completePractice) => {
                      res.status(201).json({ success: true, data: completePractice });
                    });
                  }
                }
              });
            });
          } else {
            phasesCompleted++;
            if (phasesCompleted === totalPhases) {
              getPracticeByIdAsync(practiceId, (completePractice) => {
                res.status(201).json({ success: true, data: completePractice });
              });
            }
          }
        });
      });
    } else {
      getPracticeByIdAsync(practiceId, (completePractice) => {
        res.status(201).json({ success: true, data: completePractice });
      });
    }
  });
});

// Update practice
app.put('/api/practices/:id', authenticateToken, (req, res) => {
  const id = parseInt(req.params.id);
  const { name, date, estimatedDuration, objective, phases } = req.body;
  const coachId = req.user.id;
  
  if (!name || !date) {
    return res.status(400).json({ success: false, error: 'Name and date are required' });
  }
  
  // Verify coach owns this practice
  db.get('SELECT id FROM practices WHERE id = ? AND coach_id = ?', [id, coachId], (err, practice) => {
    if (err) {
      console.error('Error checking practice ownership:', err);
      return res.status(500).json({ success: false, error: 'Internal server error' });
    }
    
    if (!practice) {
      return res.status(404).json({ success: false, error: 'Practice not found' });
    }
    
    const duration = estimatedDuration || 90;
    
    // Update practice
    db.run(`
      UPDATE practices 
      SET name = ?, date = ?, estimated_duration = ?, objective = ?
      WHERE id = ?
    `, [name, date, duration, objective || '', id], function(err) {
      if (err) {
        console.error('Error updating practice:', err);
        return res.status(500).json({ success: false, error: 'Failed to update practice' });
      }
      
      // Delete existing phases and their drill assignments
      db.run(`
        DELETE FROM practice_phase_drills 
        WHERE phase_id IN (SELECT id FROM practice_phases WHERE practice_id = ?)
      `, [id], (err) => {
        if (err) {
          console.error('Error deleting phase drills:', err);
          return res.status(500).json({ success: false, error: 'Failed to update practice phases' });
        }
        
        db.run('DELETE FROM practice_phases WHERE practice_id = ?', [id], (err) => {
          if (err) {
            console.error('Error deleting phases:', err);
            return res.status(500).json({ success: false, error: 'Failed to update practice phases' });
          }
          
          // Insert new phases
          if (phases && phases.length > 0) {
            let phasesCompleted = 0;
            const totalPhases = phases.length;
            
            phases.forEach((phase, index) => {
              db.run(`
                INSERT INTO practice_phases (practice_id, name, duration, objective, phase_order) 
                VALUES (?, ?, ?, ?, ?)
              `, [id, phase.name, phase.duration, phase.objective, index + 1], function(err) {
                if (err) {
                  console.error('Error creating phase:', err);
                  return res.status(500).json({ success: false, error: 'Failed to create practice phase' });
                }
                
                const phaseId = this.lastID;
                
                if (phase.drills && phase.drills.length > 0) {
                  let drillsCompleted = 0;
                  const totalDrills = phase.drills.length;
                  
                  phase.drills.forEach(drill => {
                    const drillId = drill.id || drill;
                    db.run(`
                      INSERT INTO practice_phase_drills (phase_id, drill_id) 
                      VALUES (?, ?)
                    `, [phaseId, drillId], (err) => {
                      if (err) {
                        console.error('Error assigning drill to phase:', err);
                        return res.status(500).json({ success: false, error: 'Failed to assign drills to phase' });
                      }
                      
                      drillsCompleted++;
                      if (drillsCompleted === totalDrills) {
                        phasesCompleted++;
                        if (phasesCompleted === totalPhases) {
                          getPracticeByIdAsync(id, (completePractice) => {
                            res.json({ success: true, data: completePractice });
                          });
                        }
                      }
                    });
                  });
                } else {
                  phasesCompleted++;
                  if (phasesCompleted === totalPhases) {
                    getPracticeByIdAsync(id, (completePractice) => {
                      res.json({ success: true, data: completePractice });
                    });
                  }
                }
              });
            });
          } else {
            getPracticeByIdAsync(id, (completePractice) => {
              res.json({ success: true, data: completePractice });
            });
          }
        });
      });
    });
  });
});

// Delete practice
app.delete('/api/practices/:id', authenticateToken, (req, res) => {
  const practiceId = parseInt(req.params.id);
  const coachId = req.user.id;
  
  // Verify coach owns this practice
  db.get('SELECT id FROM practices WHERE id = ? AND coach_id = ?', [practiceId, coachId], (err, practice) => {
    if (err) {
      console.error('Error checking practice ownership:', err);
      return res.status(500).json({ success: false, error: 'Internal server error' });
    }
    
    if (!practice) {
      return res.status(404).json({ success: false, error: 'Practice not found' });
    }
    
    // Delete related data in order
    db.run('DELETE FROM player_notes WHERE session_id IN (SELECT id FROM practice_sessions WHERE practice_id = ?)', [practiceId], function(err) {
      if (err) {
        console.error('Error deleting player notes:', err);
        return res.status(500).json({ success: false, error: 'Failed to delete practice' });
      }
      
      db.run('DELETE FROM practice_attendance WHERE session_id IN (SELECT id FROM practice_sessions WHERE practice_id = ?)', [practiceId], function(err) {
        if (err) {
          console.error('Error deleting practice attendance:', err);
          return res.status(500).json({ success: false, error: 'Failed to delete practice' });
        }
        
        db.run('DELETE FROM practice_sessions WHERE practice_id = ?', [practiceId], function(err) {
          if (err) {
            console.error('Error deleting practice sessions:', err);
            return res.status(500).json({ success: false, error: 'Failed to delete practice' });
          }
          
          db.run('DELETE FROM practice_phase_drills WHERE phase_id IN (SELECT id FROM practice_phases WHERE practice_id = ?)', [practiceId], function(err) {
            if (err) {
              console.error('Error deleting phase drills:', err);
              return res.status(500).json({ success: false, error: 'Failed to delete practice' });
            }
            
            db.run('DELETE FROM practice_phases WHERE practice_id = ?', [practiceId], function(err) {
              if (err) {
                console.error('Error deleting practice phases:', err);
                return res.status(500).json({ success: false, error: 'Failed to delete practice' });
              }
              
              db.run('DELETE FROM practices WHERE id = ?', [practiceId], function(err) {
                if (err) {
                  console.error('Error deleting practice:', err);
                  return res.status(500).json({ success: false, error: 'Failed to delete practice' });
                }
                
                res.json({ success: true, message: 'Practice deleted successfully' });
              });
            });
          });
        });
      });
    });
  });
});

// =============================================================================
// PRACTICE SESSION ENDPOINTS
// =============================================================================

// Start a practice session with attendance
app.post('/api/practice-sessions', authenticateToken, (req, res) => {
  const { practice_id, attendance } = req.body;
  const coachId = req.user.id;
  
  // Verify coach owns this practice
  db.get('SELECT * FROM practices WHERE id = ? AND coach_id = ?', [practice_id, coachId], (err, practice) => {
    if (err) {
      console.error('Error checking practice:', err);
      return res.status(500).json({ success: false, error: 'Database error' });
    }
    
    if (!practice) {
      return res.status(404).json({ success: false, error: 'Practice not found' });
    }
    
    // Create practice session
    db.run(`
      INSERT INTO practice_sessions (practice_id, status, timer_state, phase_elapsed_time, total_elapsed_time) 
      VALUES (?, 'in_progress', '{}', 0, 0)
    `, [practice_id], function(err) {
      if (err) {
        console.error('Error creating practice session:', err);
        return res.status(500).json({ success: false, error: 'Failed to create practice session' });
      }
      
      const sessionId = this.lastID;
      
      // Record attendance for each player
      if (attendance && attendance.length > 0) {
        let completed = 0;
        const total = attendance.length;
        
        attendance.forEach(record => {
          db.run(`
            INSERT INTO practice_attendance (session_id, player_id, attended, late_minutes, notes)
            VALUES (?, ?, ?, ?, ?)
          `, [
            sessionId, 
            record.player_id, 
            record.attended ? 1 : 0, 
            record.late_minutes || 0,
            record.notes || null
          ], (err) => {
            if (err) {
              console.error('Error recording attendance:', err);
              return res.status(500).json({ success: false, error: 'Failed to record attendance' });
            }
            
            completed++;
            if (completed === total) {
              getSessionByIdAsync(sessionId, (session) => {
                res.status(201).json({ success: true, data: session });
              });
            }
          });
        });
      } else {
        getSessionByIdAsync(sessionId, (session) => {
          res.status(201).json({ success: true, data: session });
        });
      }
    });
  });
});

// Complete a practice session
app.put('/api/practice-sessions/:id/complete', authenticateToken, (req, res) => {
  const sessionId = parseInt(req.params.id);
  const { actual_duration, notes } = req.body;
  const coachId = req.user.id;
  
  // Verify coach owns this session
  db.get(`
    SELECT ps.id FROM practice_sessions ps
    JOIN practices p ON ps.practice_id = p.id
    WHERE ps.id = ? AND p.coach_id = ?
  `, [sessionId, coachId], (err, session) => {
    if (err) {
      console.error('Error checking session ownership:', err);
      return res.status(500).json({ success: false, error: 'Internal server error' });
    }
    
    if (!session) {
      return res.status(404).json({ success: false, error: 'Practice session not found' });
    }
    
    db.run(`
      UPDATE practice_sessions 
      SET status = 'completed', completed_at = CURRENT_TIMESTAMP, actual_duration = ?, notes = ?
      WHERE id = ?
    `, [actual_duration, notes, sessionId], function(err) {
      if (err) {
        console.error('Error completing practice session:', err);
        return res.status(500).json({ success: false, error: 'Internal server error' });
      }
      
      res.json({ success: true, message: 'Practice session completed successfully' });
    });
  });
});

// Get active practice session
app.get('/api/practice-sessions/active', authenticateToken, (req, res) => {
  const coachId = req.user.id;
  
  const query = `
    SELECT ps.*, p.name as practice_name, p.objective, p.estimated_duration
    FROM practice_sessions ps
    JOIN practices p ON ps.practice_id = p.id
    WHERE ps.status IN ('in_progress', 'paused') AND p.coach_id = ?
    ORDER BY ps.last_activity DESC
    LIMIT 1
  `;
  
  db.get(query, [coachId], (err, session) => {
    if (err) {
      console.error('Error fetching active session:', err);
      return res.status(500).json({ success: false, error: 'Internal server error' });
    }
    
    if (session) {
      getSessionByIdAsync(session.id, (fullSession) => {
        res.json({ success: true, data: fullSession });
      });
    } else {
      res.json({ success: true, data: null });
    }
  });
});

// Get all practice sessions
app.get('/api/practice-sessions', authenticateToken, (req, res) => {
  const coachId = req.user.id;
  
  const query = `
    SELECT ps.*, p.name as practice_name, p.objective, p.estimated_duration
    FROM practice_sessions ps
    JOIN practices p ON ps.practice_id = p.id
    WHERE p.coach_id = ?
    ORDER BY ps.started_at DESC
  `;
  
  db.all(query, [coachId], (err, sessions) => {
    if (err) {
      console.error('Error fetching practice sessions:', err);
      return res.status(500).json({ success: false, error: 'Internal server error' });
    }
    
    res.json({ success: true, data: sessions });
  });
});

// Get specific practice session
app.get('/api/practice-sessions/:id', authenticateToken, (req, res) => {
  const sessionId = parseInt(req.params.id);
  const coachId = req.user.id;
  
  // Verify coach owns this session
  db.get(`
    SELECT ps.id FROM practice_sessions ps
    JOIN practices p ON ps.practice_id = p.id
    WHERE ps.id = ? AND p.coach_id = ?
  `, [sessionId, coachId], (err, session) => {
    if (err) {
      console.error('Error checking session ownership:', err);
      return res.status(500).json({ success: false, error: 'Internal server error' });
    }
    
    if (!session) {
      return res.status(404).json({ success: false, error: 'Practice session not found' });
    }
    
    getSessionByIdAsync(sessionId, (fullSession) => {
      if (fullSession) {
        res.json({ success: true, data: fullSession });
      } else {
        res.status(404).json({ success: false, error: 'Practice session not found' });
      }
    });
  });
});

// Update attendance for a practice session
app.put('/api/practice-sessions/:id/attendance', authenticateToken, (req, res) => {
  const sessionId = parseInt(req.params.id);
  const { attendance } = req.body;
  const coachId = req.user.id;
  
  // Verify coach owns this session
  db.get(`
    SELECT ps.id FROM practice_sessions ps
    JOIN practices p ON ps.practice_id = p.id
    WHERE ps.id = ? AND p.coach_id = ?
  `, [sessionId, coachId], (err, session) => {
    if (err) {
      console.error('Error checking session ownership:', err);
      return res.status(500).json({ success: false, error: 'Internal server error' });
    }
    
    if (!session) {
      return res.status(404).json({ success: false, error: 'Practice session not found' });
    }
    
    // Update all attendance records
    if (attendance && attendance.length > 0) {
      let completed = 0;
      const total = attendance.length;
      
      attendance.forEach(record => {
        db.run(`
          UPDATE practice_attendance 
          SET attended = ?, late_minutes = ?, notes = ?
          WHERE session_id = ? AND player_id = ?
        `, [
          record.attended ? 1 : 0, 
          record.late_minutes || 0, 
          record.notes || null, 
          sessionId, 
          record.player_id
        ], function(err) {
          if (err) {
            console.error('Error updating attendance:', err);
            return res.status(500).json({ success: false, error: 'Failed to update attendance' });
          }
          
          completed++;
          if (completed === total) {
            res.json({ success: true, message: 'Attendance updated successfully' });
          }
        });
      });
    } else {
      res.json({ success: true, message: 'No attendance data to update' });
    }
  });
});

// Update session notes
app.post('/api/practice-sessions/:id/notes', authenticateToken, (req, res) => {
  const sessionId = parseInt(req.params.id);
  const { notes } = req.body;
  const coachId = req.user.id;
  
  // Verify coach owns this session
  db.get(`
    SELECT ps.id FROM practice_sessions ps
    JOIN practices p ON ps.practice_id = p.id
    WHERE ps.id = ? AND p.coach_id = ?
  `, [sessionId, coachId], (err, session) => {
    if (err) {
      console.error('Error checking session ownership:', err);
      return res.status(500).json({ success: false, error: 'Internal server error' });
    }
    
    if (!session) {
      return res.status(404).json({ success: false, error: 'Practice session not found' });
    }
    
    db.run(`
      UPDATE practice_sessions 
      SET notes = ?, last_activity = CURRENT_TIMESTAMP
      WHERE id = ?
    `, [notes, sessionId], function(err) {
      if (err) {
        console.error('Error updating session notes:', err);
        return res.status(500).json({ success: false, error: 'Internal server error' });
      }
      
      res.json({ success: true, message: 'Notes updated successfully' });
    });
  });
});

// Save player notes for a practice session
app.post('/api/practice-sessions/:id/player-notes', authenticateToken, (req, res) => {
  const sessionId = parseInt(req.params.id);
  const { playerId, notes, noteType = 'practice' } = req.body;
  const coachId = req.user.id;
  
  if (!playerId || notes === undefined) {
    return res.status(400).json({ success: false, error: 'Player ID and notes are required' });
  }
  
  // Verify coach owns this session
  db.get(`
    SELECT ps.id FROM practice_sessions ps
    JOIN practices p ON ps.practice_id = p.id
    WHERE ps.id = ? AND p.coach_id = ?
  `, [sessionId, coachId], (err, session) => {
    if (err) {
      console.error('Error checking session ownership:', err);
      return res.status(500).json({ success: false, error: 'Internal server error' });
    }
    
    if (!session) {
      return res.status(404).json({ success: false, error: 'Practice session not found' });
    }
    
    db.run(`
      INSERT INTO player_notes (session_id, player_id, notes, note_type, created_at, updated_at)
      VALUES (?, ?, ?, ?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)
    `, [sessionId, playerId, notes, noteType], function(err) {
      if (err) {
        console.error('Error saving player notes:', err);
        return res.status(500).json({ success: false, error: 'Internal server error' });
      }
      
      res.json({ 
        success: true,
        message: 'Player notes saved successfully',
        data: { noteId: this.lastID }
      });
    });
  });
});

// Get player notes for a specific practice session
app.get('/api/practice-sessions/:id/player-notes/:playerId', authenticateToken, (req, res) => {
  const sessionId = parseInt(req.params.id);
  const playerId = parseInt(req.params.playerId);
  const coachId = req.user.id;
  
  // Verify coach owns this session
  db.get(`
    SELECT ps.id FROM practice_sessions ps
    JOIN practices p ON ps.practice_id = p.id
    WHERE ps.id = ? AND p.coach_id = ?
  `, [sessionId, coachId], (err, session) => {
    if (err) {
      console.error('Error checking session ownership:', err);
      return res.status(500).json({ success: false, error: 'Internal server error' });
    }
    
    if (!session) {
      return res.status(404).json({ success: false, error: 'Practice session not found' });
    }
    
    db.all(`
      SELECT * FROM player_notes 
      WHERE session_id = ? AND player_id = ?
      ORDER BY created_at ASC
    `, [sessionId, playerId], (err, notes) => {
      if (err) {
        console.error('Error fetching session player notes:', err);
        return res.status(500).json({ success: false, error: 'Internal server error' });
      }
      
      res.json({ success: true, data: notes });
    });
  });
});

// Update session timer state
app.put('/api/practice-sessions/:id/timer-state', authenticateToken, (req, res) => {
  const sessionId = parseInt(req.params.id);
  const coachId = req.user.id;
  
  // Handle both JSON and sendBeacon content types
  let data;
  if (req.is('application/json')) {
    data = req.body;
  } else {
    try {
      data = JSON.parse(req.body);
    } catch (e) {
      return res.status(400).json({ success: false, error: 'Invalid JSON data' });
    }
  }
  
  const { status, timer_state, current_phase_id, phase_elapsed_time, total_elapsed_time } = data;
  
  // Verify coach owns this session
  db.get(`
    SELECT ps.id FROM practice_sessions ps
    JOIN practices p ON ps.practice_id = p.id
    WHERE ps.id = ? AND p.coach_id = ?
  `, [sessionId, coachId], (err, session) => {
    if (err) {
      console.error('Error checking session ownership:', err);
      return res.status(500).json({ success: false, error: 'Internal server error' });
    }
    
    if (!session) {
      return res.status(404).json({ success: false, error: 'Practice session not found' });
    }
    
    db.run(`
      UPDATE practice_sessions 
      SET status = ?, timer_state = ?, current_phase_id = ?, 
          phase_elapsed_time = ?, total_elapsed_time = ?, 
          last_activity = CURRENT_TIMESTAMP
      WHERE id = ?
    `, [status, JSON.stringify(timer_state), current_phase_id, phase_elapsed_time, total_elapsed_time, sessionId], function(err) {
      if (err) {
        console.error('Error updating session timer state:', err);
        return res.status(500).json({ success: false, error: 'Failed to update session state' });
      }
      
      res.json({ success: true, message: 'Session state updated successfully' });
    });
  });
});

// Delete practice session
app.delete('/api/practice-sessions/:id', authenticateToken, (req, res) => {
  const sessionId = parseInt(req.params.id);
  const coachId = req.user.id;
  
  // Verify coach owns this session
  db.get(`
    SELECT ps.id FROM practice_sessions ps
    JOIN practices p ON ps.practice_id = p.id
    WHERE ps.id = ? AND p.coach_id = ?
  `, [sessionId, coachId], (err, session) => {
    if (err) {
      console.error('Error checking session ownership:', err);
      return res.status(500).json({ success: false, error: 'Internal server error' });
    }
    
    if (!session) {
      return res.status(404).json({ success: false, error: 'Practice session not found' });
    }
    
    // Delete in order: notes, attendance, then session
    db.run('DELETE FROM player_notes WHERE session_id = ?', [sessionId], function(err) {
      if (err) {
        console.error('Error deleting player notes:', err);
        return res.status(500).json({ success: false, error: 'Failed to delete session' });
      }
      
      db.run('DELETE FROM practice_attendance WHERE session_id = ?', [sessionId], function(err) {
        if (err) {
          console.error('Error deleting session attendance:', err);
          return res.status(500).json({ success: false, error: 'Failed to delete session' });
        }
        
        db.run('DELETE FROM practice_sessions WHERE id = ?', [sessionId], function(err) {
          if (err) {
            console.error('Error deleting practice session:', err);
            return res.status(500).json({ success: false, error: 'Failed to delete session' });
          }
          
          res.json({ success: true, message: 'Practice session deleted successfully' });
        });
      });
    });
  });
});

// Start server
const server = app.listen(PORT, HOST, () => {
  console.log('ðŸ PracTrac Backend Server Started!');
  console.log(`ðŸ“¡ Server running on http://${HOST}:${PORT}`);
  console.log(`ðŸŒ Local access: http://localhost:${PORT}`);
  console.log(`ðŸ“± Mobile access: Use your computer's IP address instead of localhost`);
  console.log(`   Example: http://192.168.1.100:${PORT}`);
});

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('\nðŸ”„ Shutting down gracefully...');
  db.close((err) => {
    if (err) {
      console.error('Error closing database:', err.message);
    } else {
      console.log('âœ… Database connection closed');
    }
    process.exit(0);
  });
});